{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf340
\cocoascreenfonts1{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{hyphen\}}{\leveltext\leveltemplateid1\'01\uc0\u8259 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{hyphen\}}{\leveltext\leveltemplateid101\'01\uc0\u8259 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{hyphen\}}{\leveltext\leveltemplateid201\'01\uc0\u8259 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid3}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}}
\margl1440\margr1440\vieww28600\viewh16220\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\b\fs24 \cf0 Introduction
\b0 \
\
Filagree is a scripting language. Its design goals are:\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\pardirnatural
\ls1\ilvl0\cf0     \uc0\u8259     simplicity\
    \uc0\u8259     portability\
    \uc0\u8259     low footprint\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 \
It is dynamically typed, garbage collected, has few keywords and minimal syntax, and integrates easily with C.\
\

\b Tutorial\

\b0 \
filagree may be built and run from the command line:\
\
    $ make\
    $ ./filagree\
    f> a = 7+8\
    f> sys.print(a)\
    15\
    f> ^D\
    $ \
\
If given an argument, it will interpret a file:\
\
    $ echo "sys.print('how you ' + 'doin')" > iamafile.fg\
    $ ./filagree imafile\
    how you doin\
    $\
\
There is one structure, a list, which may contain values indexed by number (array) and/or string (map):\
\
    a = [3, 1]\
    b = [4, 'p':5, 'q':a] \
    sys.print(b['p'] + '  ' +  b.q[0])\
    5  3\
\
Actually, any variable may contain mapped values:\
\
    a = 7                             # oh and here's a single-line comment\
    a.too = 'buckle my shoe'                /* this comment can go over multiple lines */\
\
Functions are first-order variables:\
\
    f = function(p,q,r)\
        return p+q+r, ' boo'    # r is nil\
    end\
    a, b = 7, 8\
    c, d = f(a,b)\
    sys.print(c + d)\
\
    15 boo\
\
There are two control-flow statements: if-then and while. Anything besides false, 0 or nil is true.\
\
    if 0 then\
         sys.print('zero')\
        else\
         sys.print('one')\
    end\
\
    one\
\
    if a = false then\
        sys.print('seven')\
    else if b = 8 then\
        sys.print('ate')\
    end\
\
    ate\
\
    n = 3\
    while n do\
        sys.print(n)\
        n = n-1\
    end\
\
    3\
    2\
    1\
\
There are also iterators and comprehensions:\
\
    x = [3,1,4,1,5,9]\
    y = [n+1 for n in x where n > 3]    # y = [5,6,10]\
    for z in y where z < 9 do\
        sys.print(z)\
    end\
\
    5\
    6\
\
Exceptions, and try/catch:\
\
    if n == nil then throw 'I am an exception'        # you can throw any type of value: string, int, list, etc.\
    try\
        m = n % 2\
        if m == 1 then\
            throw ['code':99, 'flavor':'strawberry']\
        end\
    catch e\
        sys.print(e.flavor + ' ice cream is yummy')\
    end\
\
A few functions come built-in, such as for serialization:\
\
    a = [2,3,4, 'x':7]\
    b = a.serialize()    # serializes any variable, including a nested structure\
    c = b.deserialize()\
    d = c.x + c[2]    # 11\
\
and file access:\
\
    x = [2,'3':4,'5']\
    sys.save(x, 'test_file')\
    y = sys.load('test_file')\
    sys.remove('test_file')\
    z = y == x            # true\
\
and sort; you provide the compare function for custom structures:\
\
    p = [3,1,4,1,5,9,6,2]\
    p.sort()                    # 1,1,2,3,4,5,6,9\
    q = [['a':3, 'b':4], ['a':2, 'b':5]]\
    q.sort(function(x,y) return y.a - x.a end)     # [['a':2, 'b':5], ['a':3, 'b':4]]\
\
and find / replace:\
\
    p = 'one two three'\
    q = p.find('two')        # q = 4\
    r = p.part(4,3)        # r = 'two'\
    s = p.replace('two', '2')    # s = 'one 2 three'\
\
and function arguments:\
\
    f = function(x,y)\
        z = sys.args()\
        return z.length\
    end\
    g = f(6,7,8,9)        # g = 4\
\
and atoi:\
\
    n,i = sys.atoi('because 345', 8)    # n = 345, i = 11\
\
\

\b Advanced Features
\b0 \
\
Short circuit:\
\
    f = function()\
        throw 99\
    end\
    g = nil or f()    # throws exception\
    h = 7 or f()    # does not throw exception\
    i = 8 and f()    # throws exception\
\
Closure:\
\
    x = 7\
    f = function(a)(x)\
        return a+x\
    end \
    g = f(3)    # g = 10\
\
Custom get and set:\
\
    x = ['get': function(self, y)        # 'get' is a reserved map key for making a custom getter\
            if not self!list then    # '!' instead of '.' means get, but not using the custom getter\
                self!list = []\
            end\
            if y == 'p' then\
                return 2\
            else\
                return 3\
            end\
        end ]\
    y = 10*x.p + x.q    # y = 23\
\
    x = ['set': function(self, y, z)        # 'set' is also reserved, for making a custom setter\
            if y == 'p' then\
                self!a = z*2    # '!' here instead of '.' means set, without the custom setter\
            else\
                self!b = z*4\
            end\
        end ]\
    x.p = 6 return 10*x.a + (x.b or 5)    # x.p = 125\
\
C integration:\
\
\pard\tx866\pardeftab866\pardirnatural
\cf0     struct variable *my_find(context_p context, const struct byte_array *name) \{\
        const char *s = byte_array_to_string(s);\
        if (!strcmp(s, "x"))\
            return variable_new_int(context, 66);\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0         return NULL;\
    \}\
\
    struct byte_array *program = build_file('sys.print(x+9) return 12');\
    struct variable *r = execute(program, &find); // prints '68'; r is a variable with r->type = VM_INT and r->integer = 12\
\
\

\b Code Structure\

\b0 \
filagree source code consists of eight modules:\
\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\pardirnatural
\ls2\ilvl0\cf0     \uc0\u8259     compile: compile fg code into byte code\
    \uc0\u8259     interpret: runs either fg code or byte code\
    \uc0\u8259     vm: virtual machine\
    \uc0\u8259     variable: variable-specific VM code\
    \uc0\u8259     sys: built-in functions, such as file and UI access\
    \uc0\u8259     serial: serializes and deserializes primitives\
    \uc0\u8259     struct: array, byte array, map and stack data structures\
    \uc0\u8259     hal: hardware abstraction layer\
    \uc0\u8259     util: miscellaneous\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural
\cf0 \
The source code includes ports to:\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\pardirnatural
\ls3\ilvl0\cf0     \uc0\u8259     Android\
    \uc0\u8259     iOS\
    \uc0\u8259     OSX\
    \uc0\u8259     Windows\
    \uc0\u8259     Linux\
(Actually, it has not been compiled for Windows yet , and there is currently only a HAL implementation for OSX.)\
}