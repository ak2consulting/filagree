# todo: has, and/or shortcut

compiler = [

    'lex' : function(self, script)

        lexeme = function(type, value)
            return ['type' : type, 'value' : value]
        end

        result = []
        i = 0

        white = ' \t\n'
        digits = '0123456789'
        vocabulary = [ '+', '-', '/*', '*/']

        while i < script.length

            while white.find(script[i]) != -1           # white space
                i = i + 1
            end

            if digits.find(script[i]) != -1             # number
                n,j = vm.atoi(script, i)
                i = i + j
                result.add(lexeme('number', n))
            else
                for word in vocabulary                  # in vocab
                    if script.find(word, i) == i then
                        result.add(lexeme('word', word))
                        i = i + word.length
        end end end end

        return result

    end,

    'parser' : [

        'parse' : function(self, lexemes)
            self.lexemes = lexemes
            self.parse_index = 0
            return self.statements()
        end,

        'statements' : function(self)
            return self.exp()
        end,

        'exp' : function(self)
            return self.symbol('expression', '+-/*', self.exp2(), self.exp2)
        end,

        'exp2' : function(self)
            return self.fetch_may(['variable', 'number', 'string'])
        end,

        'symbol' : function(self, type, sought, before, after)
            b = before
            f = self.fetch_may(sought)
            if not f then
                return b
            end
            a = self.fetch_must([after()])
            return ['type':type, 'children':[b,a]]
        end,

        'fetch_may' : function(self, options)
            if self.parse_index >= self.lexemes.length then
                return nil
            end
            l = self.lexemes[parse_index]
            if options.find(l.type) != -1 then
                return l
            end
            return nil
        end,

        'fetch_must' : function(self, options)
            f = self.fetch_may(options)
            if not f then
                throw('parse error')
            end
            return f
        end,

    ],

    'generate' : function(self, symbols)
        return 'vm.print(9)'
    end,

    'build' : function(self, input)

        lexemes = self.lex(input)
        vm.print('lexd = ' + lexemes)
        parsed = self.parser.parse(lexemes)
        program = self.generate(parsed)

        return program

    end,

    'interpret_file' : function(self, filename)

        try
            script = vm.read(filename)
            bytecode = self.build(script)
            /* vm.run(bytecode) /* bytecode() */
        catch err
            vm.print(err)
        end

    end
]

compiler.interpret_file('program.fg')